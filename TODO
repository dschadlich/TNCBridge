TNC Bridge:
	Determine proper formating of SSID
	Determine start of the APRS data

Pages:
	Map
	Telemetry Graph
		Last hear(time)
		Current Altitude
			feet
			meters
			miles
		Current Speed
			mph
			ft/s
			m/s 
		Temperatire
		Battery Voltage




 dest    GPSLJ   0 c/r=0 res=3 last=0
 source  N6XQY  12 c/r=1 res=3 last=0
 digi 1  RELAY   0   h=0 res=3 last=0
 digi 2  WIDE2   2   h=0 res=3 last=1
  000:  8e a0 a6 98 94 40 60 9c 6c b0 a2 b2 40 f8 a4 8a  .....@`.l...@...
  010:  98 82 b2 40 60 ae 92 88 8a 64 40 65 03 f0 24 47  ...@`....d@e..$G
  020:  50 52 4d 43 2c 30 31 33 36 34 31 2e 30 36 2c 41  PRMC,013641.06,A
  030:  2c 33 33 34 38 2e 31 36 30 37 2c 4e 2c 31 31 38  ,3348.1607,N,118
  040:  30 37 2e 34 36 33 31 2c 57 2c 33 34 2e 30 2c 30  07.4631,W,34.0,0
  050:  39 30 2e 35 2c 32 33 31 31 30 35 2c 31 33 2e 2c  90.5,231105,13.,
  060:  45 2a 37 33 0d                                   E*73.




var net = require("net");
var app = require('http').createServer(handler)
, io = require('socket.io').listen(app)
, fs = require('fs')
var address;


var port = process.argv.length == 3 ? Number( process.argv[2] ) : 8080;

/**
 * \brief Webserver to deliver client files.
 * @param req the request
 * @param res the response
 */
app.listen( port );
function handler (req, res) {
	fs.readFile(__dirname + '/irc_client.html',
			function (err, data) {
				if (err) {
					res.writeHead(500);
					return res.end('Error loading index.html');
				}
				res.setHeader( 'Content-Type', 'text/html;charset=UTF-8' );
				res.writeHead(200);
				res.end(data);
			});
}


/**
 * \brief This function handles the connection to the clients.
 */
io.sockets.on('connection', function (webSocket) {
    address = webSocket.handshake.address.address;

	var tcpStream = new net.Stream;
	tcpStream.setTimeout(0);
	tcpStream.setEncoding("ascii");
	webSocket.on('message', function (message) {
		try
		{
			if(message.split(' ')[0] == 'CONNECT')
			{
				//connect to the given IRC server via TCP
				var host = message.split(' ')[1].split(':')[0];
				var port = message.split(' ')[1].split(':')[1];
				console.log( 'connecting to '+host+':'+port+'���' );
				tcpStream.destroy();
				tcpStream.connect( port, host );
			}
			else
			{
				//forward message to the remote server via TCP
				tcpStream.write(message);
			}
		}
		catch (e)
		{
			webSocket.send(e);
		}
	});
	/**
	 * \brief this function closes the connection to the IRC server when the connection to the client is closed.
	 */
	webSocket.on('disconnect', function () {
		tcpStream.end();
	});

	/**
	 * \brief This function forwards error messages to the client
         */
	tcpStream.addListener("error", function (error){
		//forward error message to websocket
		webSocket.send(error+"\r\n");
	});
	/**
	 * \brief This function handles the data received from the IRC server.
	 **/
	tcpStream.addListener("data", function (data) {
		//forward data to websocket
		var regex = ":ministrystreams.com 001"
		
		var result = data.match (regex);
		if (result != null){
					//console.log ("Result: " + result[0]);

					tcpStream.write("PRIVMSG BibleUsher :chghost "+address+"\n\r")
					
		}
		
		
		regex = ":ministrystreams.com 396"
		result = data.match (regex);
		if (result != null){
			tcpStream.write("JOIN #msbob\n\r")

		}
		
		
		
		
		
		
		
		webSocket.send(data);
//		console.log ("Data: " + data);
	});
	
	
	/**
	 * \brief This function notifies the client when the connection to the server is closed.
	 **/
	tcpStream.addListener("close", function (){
		webSocket.send("Server closed connection. You are offline. Use /connect to connect.");
	});
});




var net = require("net");
var app = require('http').createServer(handler)
, io = require('socket.io').listen(app)
, fs = require('fs')


var port = process.argv.length == 3 ? Number( process.argv[2] ) : 8080;

/**
 * \brief Webserver to deliver client files.
 * @param req the request
 * @param res the response
 */
app.listen( port );
function handler (req, res) {
	fs.readFile(__dirname + '/irc_client.html',
			function (err, data) {
				if (err) {
					res.writeHead(500);
					return res.end('Error loading index.html');
				}
				res.setHeader( 'Content-Type', 'text/html;charset=UTF-8' );
				res.writeHead(200);
				res.end(data);
			});
}


/**
 * \brief This function handles the connection to the clients.
 */
io.sockets.on('connection', function (webSocket) {
	var tcpStream = new net.Stream;
	tcpStream.setTimeout(0);
	tcpStream.setEncoding("ascii");
	webSocket.on('message', function (message) {
		try
		{
			if(message.split(' ')[0] == 'CONNECT')
			{
				//connect to the given IRC server via TCP
				var host = message.split(' ')[1].split(':')[0];
				var port = message.split(' ')[1].split(':')[1];
				console.log( 'connecting to '+host+':'+port+'���' );
				tcpStream.destroy();
				tcpStream.connect( port, host );
			}
			else
			{
				//forward message to the remote server via TCP
				tcpStream.write(message);
			}
		}
		catch (e)
		{
			webSocket.send(e);
		}
	});
	/**
	 * \brief this function closes the connection to the IRC server when the connection to the client is closed.
	 */
	webSocket.on('disconnect', function () {
		tcpStream.end();
	});

	/**
	 * \brief This function forwards error messages to the client
         */
	tcpStream.addListener("error", function (error){
		//forward error message to websocket
		webSocket.send(error+"\r\n");
	});
	/**
	 * \brief This function handles the data received from the IRC server.
	 **/
	tcpStream.addListener("data", function (data) {
		//forward data to websocket
		webSocket.send(data);
	});
	
	
	/**
	 * \brief This function notifies the client when the connection to the server is closed.
	 **/
	tcpStream.addListener("close", function (){
		webSocket.send("Server closed connection. You are offline. Use /connect to connect.");
	});
});




